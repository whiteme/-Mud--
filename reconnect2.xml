<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on 星期四, 八月 09, 2012, 8:36 下午 -->
<!-- MuClient version 4.73 -->

<!-- Plugin "reconnect2" generated by Plugin Wizard -->

<muclient>
<plugin
   name="reconnect2"
   author="叶知秋"
   id="083f0cf014dbc8895a197d2a"
   language="Lua"
   purpose="叶知秋for书剑自动重连防发呆插件-屏蔽mushclient重连提示对话框"
   date_written="2016-04-20 20:34:56"
   requires="4.73"
   version="1.8"
   >
<description trim="y">
<![CDATA[
叶知秋for书剑自动重连防发呆插件
]]>
</description>

</plugin>

<!--  Script  -->


<script>
<![CDATA[

require "wait"
local auto_connect=true
local is_afk=false
local afk_cmd="set afk;unset afk"
local afk_sec=600 --默认值
--叶知秋版 自动连接防发呆插件1.8版

local function _init()
    --world.ColourNote("salmon", "", "afk:set_command cmd  - 设置 AFK 命令，cmd 为任何你想发送的 MUD 命令")
    world.ColourNote("salmon", "", "afk:set_time seconds - 设置 AFK 的时间，seconds 为大于 0 小于 3600 的数字（秒）,发送一个set afk命令")
    world.ColourNote("salmon", "", "afk:enable           - 启用 AFK 插件")
    world.ColourNote("salmon", "", "afk:disable          - 禁用 AFK 插件")
    world.ColourNote("salmon", "", "afk:show_state       - 显示 AFK 当前的状态")
	--alias
	world.AddAlias("afk_settime", "^afk:set_time (\\\d*)$", "set_AFKTime(%1)", alias_flag.Enabled + alias_flag.RegularExpression, "")
    world.SetAliasOption ("afk_settime", "send_to", 12) --向脚本发送

    --world.AddAlias("afk_cmd", "^afk:set_command (.*)$", "set_AFKCmd('%1')", alias_flag.Enabled + alias_flag.RegularExpression , "")
    --world.SetAliasOption ("afk_cmd", "send_to", 12) --向脚本发送

	world.AddAlias("afk_enable", "afk:enable", "Enable_AFK()", alias_flag.Enabled, "")
    world.SetAliasOption ("afk_enable", "send_to", 12) --向脚本发送

	world.AddAlias("afk_disable", "afk:disable", "Disable_AFK()", alias_flag.Enabled, "")
    world.SetAliasOption ("afk_disable", "send_to", 12) --向脚本发送

	world.AddAlias("heart_disable", "heart:disable", "Disable_heart()", alias_flag.Enabled, "")
    world.SetAliasOption ("heart_disable", "send_to", 12) --向脚本发送

	world.AddAlias("heart_enable", "heart:enable", "Enable_heart()", alias_flag.Enabled, "")
    world.SetAliasOption ("heart_enable", "send_to", 12) --向脚本发送

	world.AddAlias("afk_status", "afk:show_state", "Status_AFK()", alias_flag.Enabled, "")
    world.SetAliasOption ("afk_status", "send_to", 12) --向脚本发送

	world.AddAlias("afk_status", "afk:show_state", "Status_AFK()", alias_flag.Enabled, "")
    world.SetAliasOption ("afk_status", "send_to", 12) --向脚本发送

	world.AddTimer ("heart_timer", 0, 2, 0, "Heart_Beat()", timer_flag.Replace, "")
    world.SetTimerOption ("heart_timer", "send_to", 12)
	world.EnableTimer("heart_timer",true)


end

function OnPluginClose()
end

function OnPluginConnect()
   auto_connect=true
    --恢复所有暂停的计时器
   world.Execute("/Timer_Resume()")
   world.Execute("/clean_WorldAddress()")
   button()
   ColourNote("white", "red", "连上书剑世界！！")
   world.EnableTimer("reconnect_timer",false)
   world.DeleteTimer("reconnect_timer")
   world.EnableTimer("heart_timer",true)
   Enable_AFK()

end

function OnPluginDisable()
   print("自动连接插件被关闭")
end

local connect_count=0
function OnPluginDisconnect()
  if is_afk==true then
     Disable_AFK()
  end
  if auto_connect==true then
    connect_count=0
    ColourNote("white", "red", "断线，启动自动连接5秒开启连接")
    world.AddTimer ("reconnect_timer", 0, 0, 5, "sj_Connect()", timer_flag.Enabled+timer_flag.ActiveWhenClosed, "")
    world.SetTimerOption ("reconnect_timer", "send_to", 12)
  else
    ColourNote("white", "red", "离开书剑世界！！")
  end
end

function OnPluginEnable()
  print("自动连接插件被开启")
end

function sj_Connect()
   connect_count=connect_count+1
   if connect_count>9999 then
       ColourNote("white", "red", "离开书剑世界！！")
       world.EnableTimer("reconnect_timer",false)
	   world.EnableTimer("heart_timer",false)
      return
   end
   local reset_sec=5*connect_count
   local reset_min=0

   world.ColourNote("white", "red", "断线，启动自动连接"..reset_sec.."秒开启连接")

   local hour=math.floor(reset_sec/3600)
   reset_sec=reset_sec-hour*3600
   local mins=math.floor(reset_sec/60)
   reset_sec=reset_sec-mins*60
   world.SetTimerOption("reconnect_timer","hour",hour)
   world.SetTimerOption("reconnect_timer","minute",mins)
   world.SetTimerOption("reconnect_timer","second",reset_sec)
   for k, v in pairs (GetWorldIdList ()) do
      if v==world.GetWorldID() then
            --print("激活:world"..k)
            world.DoCommand("world"..k)
            --world.DoCommand("Connect")
			  world.Execute("/set_WorldAddress()")
			  world.Connect()

           break
      end
   end


   --world.Connect()
end


function mousedown()
  return function (flags, hotspot_id)
    --print(flags)

	if flags==16 then
      if auto_connect==true then
        auto_connect=false
		world.EnableTimer("reconnect_timer",false)
      else
        auto_connect=true
		world.EnableTimer("reconnect_timer",true)
      end
      button()
	end
  end
end

function switch_auto_connect(flag)--call
   auto_connect=flag
   button()
end

function disconnect()
  ColourNote("red", "black", "发呆退出书剑不再自动连接！！")
  auto_connect=false
  button()
end


function OnPluginInstall()
   ColourNote("white", "red", "叶知秋版_for_书剑_重连插件防发呆插件1.8版")
   _init()
   win="auto_connect_btn"
   WindowCreate(win,0,0,30,30,miniwin.pos_bottom_right,0,0x909090)
   local _mousedown=mousedown()
   _G["at_mousedown"]=_mousedown
   WindowAddHotspot(win, "auto_connect_hotspot",
                    0,  0, 30, 30,   -- rectangle
                   "",   -- MouseOver
                   "",   -- CancelMouseOver
                   "at_mousedown",  -- MouseDown
                   "",   -- CancelMouseDown
                   "",   -- MouseUp
                   "关闭或开启自动连接",  -- tooltip text
                   cursor or 1, -- cursor
                   0)  -- flags
   button()
   world.AddTriggerEx ("idle", "^(> |)对不起，您已经发呆超过 20 分钟了，请下次再来。$", "disconnect()", trigger_flag.RegularExpression + trigger_flag.Replace+trigger_flag.Enabled+trigger_flag.KeepEvaluating, custom_colour.NoChange, 0, "", "", 12, 40)
   world.AddTriggerEx ("leave_world", "^(> |)〖书剑〗：您本次总共在线.*。$", "world.DoAfterSpecial(1,\"world.Execute('/set_WorldAddress()')\",12)", trigger_flag.RegularExpression + trigger_flag.Replace+trigger_flag.Enabled+trigger_flag.KeepEvaluating, custom_colour.NoChange, 0, "", "", 12, 40)



end

function OnPluginSend(sText)
    if string.lower(sText)=="quit" then
      auto_connect=false
	  world.EnableTimer("heart_timer",false)
	  --button()
	  Disable_AFK()
	  --需要加入一个延迟
	  --world.EnableTimer("heart_timer",false)
	  --world.DoAfterSpecial(5,"world.Execute('/set_WorldAddress()')",12)

	elseif string.lower(sText)=="set heart_beat" then
	   --print("心跳检查")
	else
	  Reset_AFK()
	end
   --print(sText)
   return true
end

local heart_count=0
local last_bytes_count=0
local function is_DisConnected()
   --print(last_bytes_count," ? ",GetReceivedBytes())
  if last_bytes_count~=GetReceivedBytes() then
     return false
  end
  --[[
  if tonumber(SendPkt (string.char (255, 252, 31)))==0 then  --无效
     return false --无效
  end  ]]
  local line, total_lines
  local line_count=30
  total_lines = GetLinesInBufferCount ()
  for line = total_lines - line_count, total_lines do
     local row=GetLineInfo (line, 1)
	 if row~=nil then
        --Note (row)
		if string.find(row,"你只觉得头昏脑胀，眼前一黑，接着什么也不知道了") then
	      return false
	    end
	 end
  end

  return true
end

function Heart_Beat()
    world.EnableTimer("heart_timer",false)
  --world.Send("set Heart_Beat")
   --print("心跳检测")
   wait.make(function()
      local l,w=wait.regexp("^(> |)设定环境变量：Heart\\\_Beat \\\= \\\"YES\\\"$",2)
	  if l==nil then
		  if heart_count==5 then
		      if is_DisConnected() then
			    print("5次检测:",5-heart_count)
				world.Send("set Heart_Beat")
				heart_count=heart_count+1
		        Heart_Beat()
			  else
				heart_count=0
	            world.EnableTimer("heart_timer",true)
			  end
		  elseif heart_count>5 then
		      if is_DisConnected() then
				world.Execute("/Timer_Pause()")
				print("重新连接!!")
				--world.DoCommand("Disconnect")
				--wait.time(2)
                --world.DoCommand("Connect")
				world.Disconnect()
			    world.Execute("/set_WorldAddress()")
				world.Connect()
              end
 			  heart_count=0
			  world.EnableTimer("heart_timer",true)
		  else
		     if heart_count==0 then
			   last_bytes_count=GetReceivedBytes()
			 elseif last_bytes_count~=GetReceivedBytes() then
			    heart_count=0
			    world.EnableTimer("heart_timer",true)
				return
			 end
		     heart_count=heart_count+1
		     Heart_Beat()
		  end
	     return
	  end

	  if string.find(l,"设定环境变量") then
	     heart_count=0
	     world.EnableTimer("heart_timer",true)
		 return
	  end

   end)
end

function Reset_AFK()
    world.ResetTimer("afk_timer")
end

function Status_AFK()
    if is_afk==true then
       world.ColourNote("salmon", "", "AFK开启")
	else
	   world.ColourNote("salmon", "", "AFK关闭")
	end
	world.ColourNote("salmon","","检查间隔时间:"..afk_sec)
	world.ColourNote("salmon","","发送的命令:"..afk_cmd)
end

local function convert_seconds(seconds)
    local hours = math.floor(seconds / 3600)
    seconds = seconds - (hours * 3600)
    local minutes = math.floor(seconds / 60)
    seconds = seconds - (minutes * 60)
    return hours, minutes, seconds
end

function Enable_heart()
    EnableTimer("heart_timer",true)
	world.ColourNote("salmon", "", "Heart检测关闭")
end

function Disable_heart()
    EnableTimer("heart_timer",false)
	world.ColourNote("salmon", "", "Heart检测关闭")
end

function Enable_AFK()
   local hours,minutes,seconds=convert_seconds(afk_sec)
	world.AddTimer ("afk_timer", hours, minutes, seconds, afk_cmd, timer_flag.ActiveWhenClosed+timer_flag.Replace, "")
    world.SetTimerOption ("afk_timer", "send_to", 10)
	world.EnableTimer("afk_timer",true)
	Reset_AFK()
	is_afk=true
    world.SetVariable("is_afk","true")
	world.ColourNote("salmon", "", "AFK开启")
end

function Disable_AFK()
    Reset_AFK()
	world.EnableTimer("afk_timer",false)
	is_afk=false
    world.SetVariable("is_afk","false")
	world.ColourNote("salmon", "", "AFK关闭")
end

function set_AFKTime(sec) --mins sec 最大不超过60
   afk_sec=sec
   world.ColourNote("salmon","","检查间隔时间:"..afk_sec)
end

function set_AFKCmd(cmd)
   afk_cmd=cmd
   world.ColourNote("salmon","","发送的命令:"..afk_cmd)
end

function button()
  win="auto_connect_btn"
	  --text add
	  WindowFont (win, "f", "宋体", 9, true, false, false, false)
	  local switch_name=""
	  if auto_connect==true then
	     switch_name="√开"
		 ColourNote("red", "black", "自动连接开")
	  else
	     switch_name="×关"
		 ColourNote("red", "black", "自动连接关")
		 -- world.DoAfterSpecial(5,"world.Execute('/set_WorldAddress()')",12)
		  world.Execute("/set_WorldAddress()")
	  end
	 WindowRectOp (win, miniwin.rect_fill, 0,0,30,30,0x000010)  -- raised, filled, softer, flat
     WindowCircleOp (win, miniwin.circle_round_rectangle, 0, 0, 30, 30, 0xc0c0c0, 0, 1,0, 0, 9, 9)
	  WindowText (win, "f", switch_name,2,8,30,30,ColourNameToRGB ("red"), false) -- not Unicode
     WindowShow (win,  true)  -- show it
end

local is_sender=false
local omit_start=0
local omit_count=0

function OnPluginCommand (sText)
    --print(os.date().." cmd:"..sText)

   if omit_start>1 then
    -- print("start ",omit_start," count ",omit_count," 结果:true")
    omit_start=omit_start-1
     return true
   elseif omit_start<=1 and omit_count>0 then
      --print("start ",omit_start," count ",omit_count," 结果:false")
       omit_count=omit_count-1
       --omit_start=omit_start-1
      return false
   else
      --print("start ",omit_start," count ",omit_count," 结果:true")
      return true
   end
end -- function


--OnPluginCommandEntered

--
-- The player has typed the command 'sText' and pressed <Enter>
--
-- You can modify the command in this function, and return the modified string
--   which is what will be sent to the command processor.
-- If you return an empty string, that will sent to the command processor.
-- If you return a tab character on its own (\t or hex 09) then the command will be
-- discarded, and the command window cleared (unless auto-repeat commands is set).
--
-- If you return a carriage-return character on its own (\r or hex 0D) then the command will be
-- discarded, and retained in the command window.
--
-- This differs from OnPluginCommand which processes individual command lines,
--  after command stacking and other processing has taken place.
--
--  The example replaces line breaks by %r.
--
--  You might use this to implement your own "rules" for evaluating command stacking,
--  spell checking, keeping a command history, and so on.
--
local function Split(szFullString, szSeparator)
  local nFindStartIndex = 1
  local nSplitIndex = 1
  local nSplitArray = {}
  while true do
    local nFindLastIndex = string.find(szFullString, szSeparator, nFindStartIndex)
    if not nFindLastIndex then
      nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, string.len(szFullString))
      break
	end
    nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, nFindLastIndex - 1)
    nFindStartIndex = nFindLastIndex + string.len(szSeparator)
    nSplitIndex = nSplitIndex + 1
  end
  return nSplitArray
end

function marco(cmds)
   local u={}
   u=Split(cmds,"|")
   omit_start=0
   omit_count=0
   for i=1,table.getn(u) do
      local cmd=u[i]
      if string.find(cmd,"#wa") then
         omit_start=i
         omit_count=table.getn(u)-omit_start+1
	     local sec=string.gsub(cmd,"#wa","")
		 sec=Trim(sec)
		 sec=tonumber(sec) / 1000
		 --print(sec)
		 local cmds=""
		 for j=i+1,table.getn(u) do
		    cmds=cmds ..u[j].."|"
		 end

		 cmds=string.sub(cmds,1,-2)
		--print(cmds)
		 --local callback=function()
		--   marco(cmds)
		 --end
		 --f_wait(callback,sec)
         local cmd="marco('"..cmds.."')"
		 DoAfterSpecial (sec, cmd, sendto.script)
         --if is_sender==true then
         --else
           -- world.Execute(cmd) --延时引起需要发送
         --end
		 return
	  else
	     if is_sender==true then
         else
            world.Execute(cmd) --延时引起需要发送
         end
	  end
   end
end

function OnPluginCommandEntered (sText)
  --print(os.date().." cmd:",sText)
  local zmud_alias=string.gsub(sText,";","|")
    zmud_alias=Trim(zmud_alias)
   is_sender=true
    marco(zmud_alias)
   is_sender=false
end -- function


]]>
</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="reconnect2:help"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
]]>
</script>

</muclient>
