<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<!-- Bits of this plugin and ideas were borrowed and remixed from the MUSHclient community. http://www.gammon.com.au/forum/?id=9385 and others. -->
<!-- Modifications for Aardwolf and a bunch of extra awesome sauce added by Fiendish with help from Orogan -->

<muclient>
<plugin
   name="sj_Chat_Capture_Miniwindow"
   author="茶水"
   id="b555825a4a5700c35fa80780"
   language="Lua"
   purpose="茶水版_书剑聊天监控窗口"
   date_written="2010-10-25"
   requires="4.73"
   version="2.0"
   save_state="y"
>

<description trim="y">
USAGE:

   chats echo on    : echo chats in main window
   chats echo off   : do not echo chats
   chats show       : show chats window
   chats hide       : hide chats window

   Left-click a line to copy it to the clipboard
   Left-click-and-drag title bar to move window
   Right-click window to see menu of options
</description>

</plugin>

<triggers>
 <trigger
   enabled="y"
   match="^(&gt;)*( )*【闲聊】"
   omit_from_output="y"
   regexp="y"
   script="chats"
   sequence="100"
  >
  </trigger>

<trigger
   enabled="n"
   name="baowu"
   match="^(&gt;)*( )*(【谣言】某人：据说.+好象藏在.+|【谣言】某人：.+带着.+在.+一带出现)"
   regexp="y"
   script="chats"
   omit_from_output="y"
   sequence="100"
></trigger>

<trigger
   enabled="n"
   name="siliao"
   match="^(&gt;)*( )*(你告诉|.+告诉你|你回答|.+回答你)"
   regexp="y"
   script="chats"
   omit_from_output="y"
   sequence="100"
></trigger>

<trigger
   enabled="n"
   name="rumor"
   match="^(&gt;)*( )*【谣言】"
   regexp="y"
   script="chats"
   omit_from_output="y"
   sequence="100"
></trigger>

<trigger
   enabled="n"
   name="quest"
   match="^(&gt;)*( )*【谣言】某人：听说.+在.+任务中获得了一次.+的解谜机会"
   regexp="y"
   script="chats"
   omit_from_output="y"
   sequence="100"
></trigger>

<trigger
   enabled="n"
   name="quyu"
   match="^(&gt;)*( )*(【大轮寺】|【峨眉派】|【姑苏慕容】|【古墓派】|【华山派】|【昆仑派】|【灵鹫宫】|【明教】|【全真教】|【少林派】|【神龙教】|【桃花岛】|【天龙寺】|【铁掌帮】|【武当派】|【星宿派】|【丐帮】|【嵩山派】|【逍遥派】)"
   regexp="y"
   script="chats"
   omit_from_output="y"
   sequence="100"
></trigger>

<trigger
   enabled="n"
   name="duiwu"
   match="^(&gt;)*( )*【队伍】"
   regexp="y"
   script="chats"
   omit_from_output="y"
   sequence="100"
></trigger>
<trigger
   enabled="n"
   name="cisha_reward"
   match="^.*好，任务完成了，你得到了.*实战经验，.*潜能和.*正神。"
   regexp="y"
   repeat="y"
   script="chats"
   omit_from_output="y"
   sequence="100"
></trigger>
<trigger
   enabled="n"
   name="qqll_reward"
   match="^.*点实战经验"
   regexp="y"
   repeat="y"
   script="chats"
   omit_from_output="y"
   sequence="100"
></trigger>
<trigger
   enabled="n"
   name="bug_reward"
   match="^.*你的经验增加了.*，潜能增加了.*点！"
   regexp="y"
   repeat="y"
   script="chats"
   omit_from_output="y"
   sequence="100"
></trigger>
<trigger
   enabled="n"
   name="ss_reward"
   match="^.*你觉得脑中豁然开朗，增加了.*点潜能和.*点经验.*"
   regexp="y"
   repeat="y"
   script="chats"
   omit_from_output="y"
   sequence="100"
></trigger>
<trigger
   enabled="n"
   name="reward"
   match="^(&gt;)*( )*恭喜你！你成功的完成了.*任务！你被奖励了："
   regexp="y"
   repeat="y"
   script="chats"
   omit_from_output="y"
   sequence="100"
></trigger>
<trigger
   enabled="n"
   name="hb"
   match="^(&gt;)*( )*你被奖励了.*点经验，.*点潜能，.*两黄金！"
   regexp="y"
   repeat="y"
   script="chats"
   omit_from_output="y"
   sequence="100"
></trigger>

<trigger
   enabled="n"
   name="exp"
   match="^.*经验!"
   regexp="y"
   repeat="y"
   script="chats"
   omit_from_output="y"
   sequence="10"
></trigger>
<trigger
   enabled="n"
   name="pots"
   match="^.*潜能!"
   regexp="y"
   repeat="y"
   script="chats"
   omit_from_output="y"
   sequence="10"
></trigger>
<trigger
   enabled="n"
   name="shen"
   match="^.*神！"
   repeat="y"
   regexp="y"
   script="chats"
   omit_from_output="y"
   sequence="10"
></trigger>

<trigger
   enabled="n"
   match="^$"
   regexp="y"
   name="end_gag_omit"
   group="end_gag"
   omit_from_output="y"
   sequence="100"
   send_to="12"
>
<send>
   EnableTriggerGroup("end_gag", false)
</send>
</trigger>

<trigger
   enabled="n"
   match=".*"
   regexp="y"
   name="end_gag_keep"
   group="end_gag"
   omit_from_output="n"
   sequence="101"
   send_to="12"
>
<send>
   EnableTriggerGroup("end_gag", false)
</send>
</trigger>

</triggers>

<aliases>

<alias
   match="resetaard"
   enabled="y"
   sequence="100"
   ignore_case="y"
   script="reset_aard"
></alias>

<alias
   script="chat_echo"
   match="^chats echo( on| off)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="chat_show"
   match="chats show"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

<alias
   script="chat_hide"
   match="chats hide"
   enabled="y"
   sequence="100"
   ignore_case="y"
></alias>

</aliases>

<script>
<![CDATA[

require "movewindow"  -- load the movewindow.lua module
require "copytable"

SCROLL_BAR_WIDTH = 15
MAX_LINES = 1000 -- how many lines to store in scrollback

-- date_format = "[%d %b %H:%M:%S] "   -- [30 Aug 13:29:49]   date and time 24 hour
-- date_format = "[%d %b %I:%M:%S%p] " -- [30 Aug 01:20:12PM] date and time 12 hour
-- date_format = "[%H:%M:%S] "         -- [13:29:08]          time 24 hour
-- date_format = "[%X] "               -- [1:22:06 PM]        time 12 hour

default_width = 657
default_height = 131
default_x = 0
default_y = 0

echo = tonumber(GetVariable("echo")) or 1
date_format = GetVariable("date_format") or "[%d %b %H:%M:%S] "
width = tonumber(GetVariable("WINDOW_WIDTH")) or default_width
height = tonumber(GetVariable("WINDOW_HEIGHT")) or default_height
log_to_file = tonumber(GetVariable("log_to_file")) or 0
log_colour_codes = tonumber(GetVariable("log_colour_codes")) or 1
log_timestamps = tonumber(GetVariable("log_timestamps")) or 1

-- colours
WINDOW_BACKGROUND_COLOUR = GetNormalColour(1)
WINDOW_TEXT_COLOUR = 0xffffff
SCROLL_BACKGROUND_COLOUR = 0xE8E8E8
SCROLL_BAR_COLOUR = 0x111111
SCROLL_DETAIL_COLOUR = 0x000000
WINDOW_BORDER_COLOUR = 0xE8E8E8

-- offset of text from edge
TEXT_INSET = 5

-- where to store the chat line
lines = {}  -- table of recent chat lines
rawlines = {}

lineStart = ""
lineEnd = ""
WINDOW_LINES = ""

-- functions for handling Aardwolf color codes
dofile(GetPluginInfo(GetPluginID(), 20) .. "sj_colors.lua")

font_height = ""
line_height = ""
windowinfo = ""
startx = ""
starty = ""

siliao_on = tonumber(GetVariable("siliao_on")) or 0
bendi_on = tonumber(GetVariable("bendi_on")) or 0
baowu_on = tonumber(GetVariable("baowu_on")) or 0
rumor_on = tonumber(GetVariable("rumor_on")) or 0
helpme_on = tonumber(GetVariable("helpme_on")) or 0
quest_on = tonumber(GetVariable("quest_on")) or 0
quyu_on = tonumber(GetVariable("quyu_on")) or 0
duiwu_on = tonumber(GetVariable("duiwu_on")) or 0
renwu_on=tonumber(GetVariable("renwu_on")) or 0
SetTriggerOption("siliao", "enabled", siliao_on)
SetTriggerOption("bendi", "enabled", bendi_on)
SetTriggerOption("baowu", "enabled", baowu_on)
SetTriggerOption("rumor", "enabled", rumor_on)
SetTriggerOption("helpme", "enabled", helpme_on)
SetTriggerOption("quest", "enabled",quest_on)
SetTriggerOption("quyu", "enabled",quyu_on)
SetTriggerOption("duiwu", "enabled",duiwu_on)
SetTriggerOption("reward","enabled",renwu_on)
SetTriggerOption("hb","enabled",renwu_on)
SetTriggerOption("exp","enabled",renwu_on)
SetTriggerOption("shen","enabled",renwu_on)
SetTriggerOption("pots","enabled",renwu_on)
SetTriggerOption("ss_reward","enabled",renwu_on)
SetTriggerOption("bug_reward","enabled",renwu_on)
SetTriggerOption("cisha_reward","enabled",renwu_on)
SetTriggerOption("qqll_reward","enabled",renwu_on)
function reset_aard()
   width = default_width
   height = default_height
   font_name = default_font_name
   font_size = default_font_size
   windowinfo.window_left = default_x
   windowinfo.window_top = default_y
   OnPluginSaveState()
   OnPluginInstall()
end

function ResizeMoveCallback ()
   posx, posy = WindowInfo(win, 17), WindowInfo(win, 18)
   width = width+posx-startx
   startx = posx
   if (WindowTextWidth(win, win_font, "WWWCOMMUNICATION")+2*SCROLL_BAR_WIDTH > width) then
      width = WindowTextWidth(win, win_font, "WWWCOMMUNICATION")+2*SCROLL_BAR_WIDTH
      startx = windowinfo.window_left+width
   elseif (windowinfo.window_left+width > GetInfo(281)) then
      width = GetInfo(281)-windowinfo.window_left
      startx = GetInfo(281)
   end
   height = height+posy-starty
   starty=posy
   if (3*SCROLL_BAR_WIDTH+10+line_height+TITLE_HEIGHT > height) then
      height = 3*SCROLL_BAR_WIDTH+10+line_height+TITLE_HEIGHT
      starty = windowinfo.window_top+height
   elseif (windowinfo.window_top+height > GetInfo(280)) then
      height = GetInfo(280)-windowinfo.window_top
      starty = GetInfo(280)
   end
   init(false)
end

function ResizeReleaseCallback ()
   height = TITLE_HEIGHT+(line_height*(WINDOW_LINES-1))+3 -- snap height down to not have dead space after last line
   init(true) -- true here causes old lines to re-wrap at the new size
end

win = GetPluginID()
require "checkplugin"
function OnPluginListChanged ()
   do_plugin_check_now("462b665ecb569efbf261422f", "sj_mw_z_order_monitor")    -- check we have z order plugin
end -- OnPluginListChanged

function OnPluginInstall ()
   -- Dummy window to get font characteristics
   check(WindowCreate(win, 0, 0, 1, 1, 0, 0, WINDOW_BACKGROUND_COLOUR))

   local fonts = utils.getfontfamilies ()
   if fonts["宋体"] then
      default_font_size = 9
      default_font_name = "宋体"
   elseif fonts["FixedSys"] then
      default_font_size = 9
      default_font_name = "FixedSys"
   elseif fonts ["Courier New"] then
      default_font_size = 9
      default_font_name = "Courier New" -- the actual font
   else
      default_font_size = 9
      default_font_name = "Lucida Console"
   end -- if

   font_name = GetVariable("font_name") or default_font_name
   font_size = tonumber(GetVariable("font_size")) or default_font_size

   header_font_name = font_name
   header_font_size = font_size

   win_font = "font"..win
   win_head_font = "fonthead"..win
   check(WindowFont(win, win_font, font_name, font_size))
   check(WindowFont(win, win_head_font, header_font_name, header_font_size))

   font_height = WindowFontInfo(win, win_font, 1) -  WindowFontInfo(win, win_font, 4) + 1
   header_font_height = WindowFontInfo(win, win_head_font, 1) - WindowFontInfo(win, win_head_font, 4) + 1
   TITLE_HEIGHT = header_font_height*1.8
   line_height = font_height+1

   -- install the window movement handler, get back the window position
   windowinfo  = movewindow.install(win, miniwin.pos_top_right, miniwin.create_absolute_location, false, nil, {mouseup=MouseUp, mousedown=LeftClickOnly, dragmove=LeftClickOnly, dragrelease=LeftClickOnly},{x=default_x, y=default_y})

   init(true)
   -- if disabled last time, stay disabled
   if GetVariable ("enabled") == "false" then
      ColourNote ("yellow", "", "Warning: Plugin " .. GetPluginName ().. " is currently disabled.")
      check (EnablePlugin(GetPluginID (), false))
      return
   else
      OnPluginEnable()  -- do initialization stuff
   end-- they didn't enable us last time
end

function init (firstTime)
   -- how many lines and columns will fit?
   WINDOW_LINES = math.ceil((height-TITLE_HEIGHT)/line_height)

   if (firstTime == true) then
      WindowCreate(win, windowinfo.window_left, windowinfo.window_top, width, height, windowinfo.window_mode, windowinfo.window_flags, WINDOW_BACKGROUND_COLOUR)

      -- catch for right-click menu and line selection
      WindowAddHotspot(win, "textarea", 1, TITLE_HEIGHT, width-SCROLL_BAR_WIDTH-1,height-3, "", "", "MouseDown", "CancelMouseDown", "MouseUp", "", 2, 0)
      WindowDragHandler(win, "textarea", "TextareaMoveCallback", "TextareaReleaseCallback", 0x10)

      -- mouse wheel handler for scrolling up/down
      WindowScrollwheelHandler(win, "textarea", "wheel_move")

      -- add the drag handler so they can move the window around
      movewindow.add_drag_handler(win, 0, 0, 0, TITLE_HEIGHT)

      -- scroll bar up/down buttons
      WindowAddHotspot(win, "up", width-SCROLL_BAR_WIDTH, TITLE_HEIGHT, 0, TITLE_HEIGHT+SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
      WindowAddHotspot(win, "down", width-SCROLL_BAR_WIDTH, height-(2*SCROLL_BAR_WIDTH), 0, height-SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)

      -- add the resize widget hotspot
      WindowAddHotspot(win, "resize", width-SCROLL_BAR_WIDTH, height-SCROLL_BAR_WIDTH, width, height, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 6, 0)
      WindowDragHandler(win, "resize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)

      -- re-wrap buffered lines at the new size
      lines = {}
      for _,styles in ipairs(rawlines) do
         fillBuffer(styles[1],styles[2])
      end
      CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", win) -- fail silently
   else
      WindowResize(win, width, height, WINDOW_BACKGROUND_COLOUR)
      WindowMoveHotspot(win, "textarea", 0, TITLE_HEIGHT, width-SCROLL_BAR_WIDTH-1, height-3)
      WindowMoveHotspot(win, "up", width-SCROLL_BAR_WIDTH, TITLE_HEIGHT, 0, TITLE_HEIGHT+SCROLL_BAR_WIDTH)
      WindowMoveHotspot(win, "down", width-SCROLL_BAR_WIDTH, height-(2*SCROLL_BAR_WIDTH), 0, height-SCROLL_BAR_WIDTH)
      WindowMoveHotspot(win, "resize", width-SCROLL_BAR_WIDTH, height-SCROLL_BAR_WIDTH, width, 0)
   end
   WindowShow(win, true)

   lineStart = math.max(1, #lines-WINDOW_LINES+2)
   lineEnd = math.max(1, #lines)

   -- title rectangle
   header_width = WindowTextWidth(win, win_head_font, "书剑聊天窗口")
   WindowGradient(win, 1, 0, width, TITLE_HEIGHT, WINDOW_BACKGROUND_COLOUR, 0x444444, 2)
   WindowText(win, win_head_font, "书剑聊天窗口", (width-header_width)/2, ((TITLE_HEIGHT-header_font_height)/2)-1, width, TITLE_HEIGHT, 0xEEEEEE, false)
   WindowLine(win, 0, TITLE_HEIGHT-1, width, TITLE_HEIGHT-1, WINDOW_BORDER_COLOUR, 0 + 0x0200, 1)

   -- resize tag
   WindowRectOp(win, 2, width-SCROLL_BAR_WIDTH, height-SCROLL_BAR_WIDTH, 0, 0, SCROLL_BACKGROUND_COLOUR) -- resizer background
   WindowLine(win, width-SCROLL_BAR_WIDTH+1, height-2, width-2, height-SCROLL_BAR_WIDTH+1, 0xffffff, 0, 2)
   WindowLine(win, width-SCROLL_BAR_WIDTH+2, height-2, width-2, height-SCROLL_BAR_WIDTH+2, 0x696969, 0, 1)
   WindowLine(win, width-SCROLL_BAR_WIDTH+4, height-2, width-2, height-SCROLL_BAR_WIDTH+4, 0xffffff, 0, 2)
   WindowLine(win, width-SCROLL_BAR_WIDTH+5, height-2, width-2, height-SCROLL_BAR_WIDTH+5, 0x696969, 0, 1)
   WindowLine(win, width-SCROLL_BAR_WIDTH+7, height-2, width-2, height-SCROLL_BAR_WIDTH+7, 0xffffff, 0, 2)
   WindowLine(win, width-SCROLL_BAR_WIDTH+8, height-2, width-2, height-SCROLL_BAR_WIDTH+8, 0x696969, 0, 1)
   WindowLine(win, width-SCROLL_BAR_WIDTH+10, height-2, width-2, height-SCROLL_BAR_WIDTH+10, 0xffffff, 0, 2)
   WindowLine(win, width-SCROLL_BAR_WIDTH+11, height-2, width-2, height-SCROLL_BAR_WIDTH+11, 0x696969, 0, 1)

   -- draw border
   WindowRectOp(win, 1, 0, 0, 0, 0, WINDOW_BORDER_COLOUR)

   drawStuff()
end

function OnPluginClose ()
   -- if enabled
   if GetPluginInfo(GetPluginID(), 17) then
      OnPluginDisable()
   end -- if enabled
end -- OnPluginClose

function OnPluginEnable ()
   WindowShow(win, true)
   -- if we are connected when the plugin loads, it must have been reloaded while playing
   if IsConnected() then
   end -- if already connected
   OnPluginSaveState()
end -- OnPluginEnable

function OnPluginSaveState()
   -- save window current location for next time
   SetVariable("enabled", tostring (GetPluginInfo (GetPluginID(), 17)))
   movewindow.save_state(win)

   SetVariable("font_name", font_name)
   SetVariable("font_size", font_size)
   SetVariable("echo", echo)
   SetVariable("date_format", date_format)
   SetVariable("WINDOW_WIDTH", width)
   SetVariable("WINDOW_HEIGHT", height)
   SetVariable("log_to_file", log_to_file)
   SetVariable("log_colour_codes", log_colour_codes)
   SetVariable("log_timestamps", log_timestamps)
   SetVariable("siliao_on", siliao_on)
   SetVariable("bendi_on", bendi_on)
   SetVariable("baowu_on", baowu_on)
   SetVariable("rumor_on", rumor_on)
   SetVariable("helpme_on", helpme_on)
   SetVariable("quest_on", quest_on)
   SetVariable("quyu_on", quyu_on)
   SetVariable("duiwu_on", duiwu_on)
   SetVariable("renwu_on",renwu_on)
end --  OnPluginSaveState

function OnPluginDisable()
   WindowShow( win, false )
   OnPluginSaveState()
end --  OnPluginDisable

-- display one line
function Display_Line (line, styles, backfill_start, backfill_end)
   local left = TEXT_INSET
   local top = TITLE_HEIGHT+(line*line_height)
   if (backfill_start ~= nil and backfill_end ~= nil) then
      WindowRectOp(win, 2, backfill_start, top+1, backfill_end, top+line_height+1, 0x444444)
   end -- backfill
   if styles then
      for _, v in ipairs(styles) do
         local t = v.text
         -- now clean up dangling newlines that cause block characters to show
         if string.sub(v.text,-1) == "\n" then
            t = string.sub(v.text,1,-2)
         end
         left = left + WindowText(win, win_font, t, left, top,  width-SCROLL_BAR_WIDTH, 0, v.textcolour)
      end -- for each style run
   end
end -- Display_Line

-- Returns an array {start, end, text}
function findURLs(text)
   local URLs = {}
   local start, position = 0, 0
   -- "rex" is a table supplied by MUSHclient for PCRE functionality.
   local re = rex.new("(?:https?://|mailto:)\\S*[\\w/=@#\\-\\?]")
   re:gmatch(text,
      function (link, _)
         start, position = string.find(text, link, position, true)
         table.insert(URLs, {start=start, stop=position, text=link})
      end
   )
   return URLs
end -- function findURL

-- display all visible lines
hyperlinks = {}
function writeLines ()
   WindowRectOp(win, 2, 1, TITLE_HEIGHT, width-SCROLL_BAR_WIDTH, -1, WINDOW_BACKGROUND_COLOUR) -- clear
   local ax = nil
   local zx = nil
   local line_no_colors = ""
   if #lines >= 1 then
      for count = lineStart, lineEnd do
         ax = nil
         zx = nil
         line_no_colors = strip_colours(StylesToColoursOneLine(copytable.deep(lines[count][1]), 1, 99999))

         -- create clickable links for urls
         for i,v in ipairs(lines[count][3]) do
            local left = TEXT_INSET+WindowTextWidth(win, win_font, string.sub(line_no_colors, 1, v.start-1))
            local right = left+WindowTextWidth(win, win_font, string.sub(line_no_colors, v.start-1, v.stop-1))
            local top = TITLE_HEIGHT+((count-lineStart)*line_height)-1
            local bottom = top+line_height+1
            local link_name = table.concat({v.text,"   ",count,v.start,v.stop})
            if not WindowHotspotInfo(win, link_name, 1) then
               hyperlinks[link_name] = v.text
               WindowAddHotspot(win, link_name, left, top, math.min(right, width-SCROLL_BAR_WIDTH-1), bottom, "MouseOverLink", "CancelMouseOverLink", "MouseDown", "CancelMouseDown", "MouseUp", "Right-click this URL if you want to open it:\n"..v.text, 1)
               WindowDragHandler(win, link_name, "TextareaMoveCallback", "TextareaReleaseCallback", 0x10)
               WindowScrollwheelHandler(win, link_name, "wheel_move")
            end
         end

         -- create highlighting parameters when text is selected
         if copy_start_line ~= nil and copy_end_line ~= nil and count >= copy_start_line and count <= copy_end_line then
            ax = (((count == copy_start_line) and math.min(start_copying_x, WindowTextWidth(win, win_font, line_no_colors)+TEXT_INSET)) or TEXT_INSET)
            -- end of highlight for this line
            zx = math.min(width-SCROLL_BAR_WIDTH,(((count == copy_end_line) and math.min(end_copying_x, WindowTextWidth(win, win_font, line_no_colors)+TEXT_INSET)) or WindowTextWidth(win, win_font, line_no_colors)+TEXT_INSET))
         end

         Display_Line( count-lineStart, lines[count][1], ax, zx )
      end
   end
   Repaint()
end

barPos = ""
barSize = ""
totalSteps = ""
function drawStuff ()

   -- Scrollbar base
   WindowRectOp(win, 2, width-SCROLL_BAR_WIDTH, TITLE_HEIGHT, width, -SCROLL_BAR_WIDTH, SCROLL_BACKGROUND_COLOUR) -- scroll bar background
   WindowRectOp(win, 1, width-SCROLL_BAR_WIDTH+1, SCROLL_BAR_WIDTH+TITLE_HEIGHT+1, width-1, height-(2*SCROLL_BAR_WIDTH)-1, SCROLL_DETAIL_COLOUR) -- scroll bar background inset rectangle

   if (keepscrolling == "up") then
      -- draw top scroll button pressed
      WindowRectOp(win, 5, (width-SCROLL_BAR_WIDTH), TITLE_HEIGHT, 0, TITLE_HEIGHT+SCROLL_BAR_WIDTH, 10,  15 + 0x800) -- up arrow pushed
      points = string.format("%i,%i,%i,%i,%i,%i", (width-SCROLL_BAR_WIDTH)+3, TITLE_HEIGHT+9,(width-SCROLL_BAR_WIDTH)+7, TITLE_HEIGHT+5,(width-SCROLL_BAR_WIDTH)+11, TITLE_HEIGHT+9)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw top scroll button unpressed
      WindowRectOp(win, 5, (width-SCROLL_BAR_WIDTH), TITLE_HEIGHT, width, TITLE_HEIGHT+SCROLL_BAR_WIDTH, 5, 15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (width-SCROLL_BAR_WIDTH)+3, TITLE_HEIGHT+9,(width-SCROLL_BAR_WIDTH)+7, TITLE_HEIGHT+5,(width-SCROLL_BAR_WIDTH)+11, TITLE_HEIGHT+9)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false)  --alt fill
   end

   if (keepscrolling == "down") then
      -- draw bottom scroll button pressed
      WindowRectOp(win, 5, (width-SCROLL_BAR_WIDTH), height-(SCROLL_BAR_WIDTH*2), 0, height-SCROLL_BAR_WIDTH-1, 10,  15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (width-SCROLL_BAR_WIDTH)+3, (height-SCROLL_BAR_WIDTH)-11,(width-SCROLL_BAR_WIDTH)+7, (height-SCROLL_BAR_WIDTH)-7, (width-SCROLL_BAR_WIDTH)+11,(height-SCROLL_BAR_WIDTH)-11)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw bottom scroll button unpressed
      WindowRectOp(win, 5, (width-SCROLL_BAR_WIDTH), height-(SCROLL_BAR_WIDTH*2), width, height-SCROLL_BAR_WIDTH, 5,  15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (width-SCROLL_BAR_WIDTH)+3, (height-SCROLL_BAR_WIDTH)-11,(width-SCROLL_BAR_WIDTH)+7, (height-SCROLL_BAR_WIDTH)-7, (width-SCROLL_BAR_WIDTH)+11,(height-SCROLL_BAR_WIDTH)-11)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false) --alt fill
   end

   -- The scrollbar position indicator
   totalSteps = #lines
   if (totalSteps <= WINDOW_LINES-1) then
      totalSteps = 1
   end
   SCROLL_BAR_HEIGHT = (height-(3*SCROLL_BAR_WIDTH)-TITLE_HEIGHT)
   if (not dragscrolling) then
      stepNum = lineStart-1
      barPos = SCROLL_BAR_WIDTH +TITLE_HEIGHT+ ((SCROLL_BAR_HEIGHT/totalSteps) * stepNum)
      barSize = (SCROLL_BAR_HEIGHT/math.max(WINDOW_LINES-1,totalSteps)) * (WINDOW_LINES-1)
      if barSize < 10 then
         barSize = 10
      end
      if barPos+barSize > SCROLL_BAR_WIDTH+TITLE_HEIGHT+SCROLL_BAR_HEIGHT then
         barPos = SCROLL_BAR_WIDTH+TITLE_HEIGHT+SCROLL_BAR_HEIGHT - barSize
      end
      WindowAddHotspot(win, "scroller", (width-SCROLL_BAR_WIDTH), barPos, width, barPos+barSize, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
      WindowDragHandler(win, "scroller", "ScrollerMoveCallback", "ScrollerReleaseCallback", 0)
   end
   WindowRectOp(win, 5, (width-SCROLL_BAR_WIDTH), barPos, width, barPos+barSize, 5, 15 + 0x800) -- scrollbar position indicator

   -- reset hyperlinks if the text moves
   for k,v in pairs(hyperlinks) do
      WindowDeleteHotspot(win, k)
   end
   hyperlinks = {}

   writeLines()
end

function wheel_move (flags, hotspot_id)
   if bit.band(flags, 0x100) ~= 0 then
      if lineStart < #lines-WINDOW_LINES+2 then
         -- down
         lineStart = math.max(1, math.min(#lines-WINDOW_LINES+2, lineStart+3))
         lineEnd = math.min(#lines, lineStart+WINDOW_LINES-2)
         drawStuff()
      end
   elseif lineStart > 1 then
      -- up
      lineStart = math.max(1, lineStart-3)
      lineEnd = math.min(#lines, lineStart+WINDOW_LINES-2)
      drawStuff()
  end -- if
end -- wheel_move

function ScrollerMoveCallback(flags, hotspot_id)
   mouseposy = WindowInfo(win, 18)
   windowtop = WindowInfo(win, 2)
   barPos = math.max(mouseposy-windowtop+clickdelta, SCROLL_BAR_WIDTH+TITLE_HEIGHT)
   if barPos > height-(SCROLL_BAR_WIDTH*2)-barSize then
      barPos = height-(SCROLL_BAR_WIDTH*2)-barSize
      lineStart = math.max(1,#lines-WINDOW_LINES+2)
      lineEnd = #lines
   else
      lineStart = math.max(1,math.floor((barPos-SCROLL_BAR_WIDTH-TITLE_HEIGHT)/(SCROLL_BAR_HEIGHT/totalSteps)+1))
      lineEnd = math.min(lineStart + WINDOW_LINES-2, #lines)
   end
   drawStuff()
end

function ScrollerReleaseCallback(flags, hotspot_id)
   dragscrolling = false
   drawStuff()
end

function add_line ( line, is_beginning_of_message, urls )
   -- add new line
   table.insert(lines, {[1]=line, [2]=is_beginning_of_message, [3]=urls} )
   -- advance the count
   if #lines >= WINDOW_LINES then
      lineStart = lineStart + 1
   end -- if

   if #lines > 1 then
      lineEnd = lineEnd + 1
   end -- if
end -- add_line

function fillBuffer(rawstyles, rawurls)
   local avail = width - (TEXT_INSET * 2) - 9
   local line_styles = {}
   local beginning = true
   local length = 0
   local styles = copytable.deep(rawstyles)
   local urls = copytable.deep(rawurls)

   -- It turns out you can reduce the function
   -- call time by instantiating functions as local.
   -- This is really just me being silly.
   local remove = table.remove
   local insert = table.insert

   -- Keep pulling out styles and trying to fit them on the current line
   while #styles > 0 do
      -- break off the next style
      local style = remove(styles, 1)

      -- make this handle forced newlines like in the flickoff social
      -- by splitting off and sticking the next part back into the
      -- styles list for the next pass
      foundbreak = false
      newline = string.find(style.text, "\n")
      if newline then
         insert(styles, 1, {text = string.sub(style.text,newline+1),
            length = style.length-newline+1,
            textcolour = style.textcolour,
            backcolour = style.backcolour}
         )
-- we're leaving in the newline characters here because we need to be
-- able to copy them later. I'll clean up the buggy visual later when
-- actually displaying the lines.
         style.length = newline
         style.text = string.sub(style.text,1,newline)
         foundbreak = true
      end

      local text_width = WindowTextWidth(win, win_font, style.text)

      -- if it fits, copy whole style in
      if text_width <= avail then
         insert(line_styles, style)
         length = length + style.length
         avail = avail - text_width
         if foundbreak then
            avail = 0
         end
      else -- otherwise, have to split style
         -- look for trailing space (work backwards). remember where space is
         local col = style.length - ((style.text:sub(1,style.length):find("[\001-\127]$")==nil and 2) or 1) --修改
         local split_col
         -- keep going until out of columns
         while col > 1 do
            text_width = WindowTextWidth(win, win_font, style.text:sub(1, col))
            if text_width <= avail then

                split_col = col
                break
            end -- if will now fit
            col = col - ((style.text:sub(1,col):find("[\001-\127]$")==nil and 2) or 1)
         end -- while

         if split_col then
            -- if we found a place to split, use old style and truncate it.
            -- Also stick the rest back with the same styling back into the styles list
            insert(line_styles, style)
            local style_copy = copytable.shallow(style)
            style.text = style.text:sub(1, split_col)
            style.length = split_col
            style_copy.text = style_copy.text:sub(split_col + 1)
            style_copy.length = #style_copy.text
            insert(styles, 1, style_copy)
            length = length + style.length
         elseif next(line_styles) == nil then
         -- Actually, I don't think this can ever happen. -Fiendish
            insert(line_styles, style)
            length = length + style.length
         else
            -- if we're about to start a new style and the
            -- line is completely full, put it back in the list for later
            insert(styles, 1, style)
         end -- if
         avail = 0  -- now we need to wrap
      end -- if could/not fit whole thing in

      -- out of styles or out of room? add a line for what we have so far
      if #styles == 0 or avail <= 0 then
         if #lines >= MAX_LINES then
            -- if the history buffer is full then remove the oldest line
            remove(lines, 1)
            lineStart = lineStart - 1
            lineEnd = lineEnd - 1
         end -- buffer full

         local line_urls = {}
         while urls[1] and urls[1].stop <= length do
            insert(line_urls, remove(urls, 1))
         end
         if urls[1] and urls[1].start < length then
            local url = copytable.deep(urls[1])
            url.stop = length + 1
            urls[1].stop = urls[1].stop-1
            urls[1].old = true
            insert(line_urls, url)
         end
         for i,v in ipairs(urls) do
            urls[i].start = urls[i].start - length
            urls[i].stop = urls[i].stop - length
            if urls[i].start <= 1 then
               urls[i].start = 1
               urls[i].stop = urls[i].stop+1
            end
         end

         add_line( line_styles, beginning, line_urls )

         avail = width - (TEXT_INSET * 2) - 9
         line_styles = {}
         length = 0
         beginning = false
      end -- line full
   end -- while we still have styles over
end

function stampAndStore(styles)

   local local_styles = copytable.deep(styles)
   local text = ""
   local log_text = ""

   -- inject timestamp if wanted
   if date_format ~= "" then
      tstamp = os.date(date_format)
      timestyle = {}
      timestyle.text = tstamp
      timestyle.length = #timestyle.text
      timestyle.textcolour = 0xc0c0c0
      table.insert(styles,1,timestyle)
   end -- if

   text = StylesToColoursOneLine(copytable.deep(styles), 1, 1000)

   if (log_to_file == 1) then
      if (log_timestamps == 0) then
         log_text = StylesToColoursOneLine(local_styles, 1, 1000)
      else
         log_text = text
      end
      if (log_colour_codes == 0) then
         log_text = strip_colours(log_text)
      end
      local f = assert(io.open (GetInfo(58):gsub("^\.\\",GetInfo(56))..GetInfo(2).."ChatLog.txt", "a+")) -- handle to chat log file
      f:write(log_text.."\n") -- write to it
      f:close()  -- close that file now
   end

   local urls = findURLs(strip_colours(text))

   -- store the raw lines for use during resizing
   if #rawlines >= MAX_LINES then
      table.remove(rawlines, 1)
   end
   table.insert(rawlines, {[1]=styles, [2]=urls})

   fillBuffer(styles, urls)
   drawStuff()
end

function echoStyles (styles)
   for _, v in ipairs(styles) do
      ColourTell(RGBColourToName(v.textcolour), RGBColourToName(v.backcolour), v.text)
   end -- for each style run
   Note ("")  -- wrap up line
end

function chats (name, line, wildcards, styles)
   if (echo == 0) then
      EnableTriggerGroup("end_gag", true) -- gags the trailing blank line if compact is off
   end

   if echo == 1 then
      -- display
      echoStyles(styles)
   end -- echo wanted

   stampAndStore(styles)
end -- chats

keepscrolling = ""
require "wait"

function scrollbar()
   wait.make(
   function()
      while keepscrolling == "up" or keepscrolling == "down" do
         if keepscrolling == "up" then
            if (lineStart > 1) then
               lineStart = lineStart - 1
               lineEnd = lineEnd - 1
            else
                 keepscrolling = ""
            end
         elseif keepscrolling == "down" then
            if (lineEnd < #lines) then
               lineStart = lineStart + 1
               lineEnd = lineEnd + 1
            else
               keepscrolling = ""
            end
         end
         wait.time(0.1)
         drawStuff()
      end
   end
   )
end

function GetAllBufferedMessages()
   local t = {}
   for _,styles in ipairs(rawlines) do
      table.insert(t, StylesToColoursOneLine(copytable.deep(styles[1]), 1, 99999)) -- 99999 basically means don't truncate lines
   end
   SetClipboard(table.concat(t,"\n"))
end

function MouseOver(flags, hotspot_id)
   keepscrolling = ""
end

function CancelMouseOver(flags, hotspot_id)
   keepscrolling = ""
end

function MouseOverLink(flags, hotspot_id)
   local url = string.gsub(hotspot_id, "(.*)   .*", "%1")
   local hotspots = WindowHotspotList(win)
   for _, v in ipairs (hotspots) do
      if string.find(v, url, 1, true) then
         local left = WindowHotspotInfo(win, v, 1)
         local right = WindowHotspotInfo(win, v, 3)
         local bottom = WindowHotspotInfo(win, v, 4)
         WindowLine(win, left, bottom, right, bottom, 0xffffff, 256, 1);
      end
   end
   Repaint()
end

function CancelMouseOverLink(flags, hotspot_id)
   local url = string.gsub(hotspot_id, "(.*)   .*", "%1")
   if not string.find(WindowInfo(win, 19), url) then
      writeLines()
   end
end

temp_start_copying_x = 0
start_copying_y = 0
copied_text = ""
function MouseDown(flags, hotspot_id)
   if (hotspot_id == "resize") then
      startx, starty = WindowInfo (win, 17), WindowInfo (win, 18)
   elseif (hotspot_id == "scroller") then
      clickdelta = WindowHotspotInfo(win, "scroller", 2)-WindowInfo (win, 15)
      dragscrolling = true
   elseif (hotspot_id == "up" or hotspot_id == "down") then
      keepscrolling = hotspot_id
      scrollbar()
   elseif (flags == 0x10) then
      temp_start_copying_x = WindowInfo(win, 14)
      start_copying_y = WindowInfo(win, 15)
      copy_start_windowline = math.floor((start_copying_y-TITLE_HEIGHT)/line_height)
      temp_start_line = copy_start_windowline+lineStart
      copied_text = ""
      copy_start_line = nil
      copy_end_line = nil
      writeLines()
   end
end

function CancelMouseDown(flags, hotspot_id)
   keepscrolling = ""
   drawStuff()
end

end_copying_x = 0
end_copying_y = 0
function MouseUp(flags, hotspot_id)
   if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
      right_click_menu(hotspot_id)
   else
      drawStuff()
   end
   keepscrolling = ""
   return true
end

function TextareaMoveCallback(flags, hotspot_id)
   if bit.band (flags, miniwin.hotspot_got_lh_mouse) ~= 0 then -- only on left mouse button
      copied_text = ""
      end_copying_x = WindowInfo(win, 17)-WindowInfo(win, 1)
      end_copying_y = WindowInfo(win, 18)-WindowInfo(win, 2)
      local ypos = end_copying_y
      end_copying_x = math.max(TEXT_INSET,math.min(end_copying_x, width-SCROLL_BAR_WIDTH))
      end_copying_y = math.max(TITLE_HEIGHT+1,math.min(end_copying_y, TITLE_HEIGHT-1+(line_height*(WINDOW_LINES-1))))
      copy_end_windowline = math.floor((end_copying_y-TITLE_HEIGHT)/line_height)
      copy_end_line = copy_end_windowline+lineStart
      copy_start_line = temp_start_line
      start_copying_x = temp_start_copying_x
      if (copy_start_line > #lines) then
         start_copying_x = width-SCROLL_BAR_WIDTH
      end

      -- the user is selecting backwards, so reverse the start/end orders
      if copy_end_line < temp_start_line then
         local temp = copy_end_line
         copy_end_line = copy_start_line
         copy_start_line = temp
         temp = end_copying_x
         end_copying_x = start_copying_x
         start_copying_x = temp
      end -- if
      if copy_end_line == copy_start_line and end_copying_x < start_copying_x then
         local temp = end_copying_x
         end_copying_x = start_copying_x
         start_copying_x = temp
      end -- if

      for copy_line=copy_start_line,copy_end_line do
         if (lines[copy_line] ~= nil) then
            local startpos = 1
            local endpos = 99999
            if (copy_line-lineStart+1 > 0 and copy_line-lineStart < WINDOW_LINES and copy_line-lineStart < #lines) then
               -- snap to character boundaries instead of selecting arbitrary pixel widths
               local line_no_colors = strip_colours(StylesToColoursOneLine(copytable.deep(lines[copy_line][1]), 1, 99999))
               startpos = 1
               endpos = #line_no_colors
               -- special deal for the first line
               if copy_line == copy_start_line then
                  for pos=1,#line_no_colors do
                     startpos = pos
                     if WindowTextWidth(win, win_font, string.sub(line_no_colors,1,pos)) > start_copying_x then
                        start_copying_x = WindowTextWidth(win, win_font, string.sub(line_no_colors,1,pos-1))+TEXT_INSET
                        break
                     end
                  end
               end
               -- special deal for the last line
               if copy_line == copy_end_line then
                  local found = false
                  endpos = 0
                  for pos=1,#line_no_colors do
                     if WindowTextWidth(win, win_font, string.sub(line_no_colors,1,pos)) > end_copying_x then
                        end_copying_x = WindowTextWidth(win, win_font, string.sub(line_no_colors,1,endpos))+TEXT_INSET
                        found = true
                        break
                     end
                     endpos = pos
                  end
               end
            end -- if should show highlight

            -- store selected area for later
            copied_part = StylesToColoursOneLine(copytable.deep(lines[copy_line][1]), startpos, endpos)
            if copy_line ~= copy_end_line and copy_line ~= #lines and lines[copy_line+1][2] == true then
               -- only put a line break if the next line is from a different message
               copied_part = copied_part.."@w\n"
            elseif copy_line == copy_end_line or copy_line == #lines then
               -- tack a white code on to the very end
               copied_part = copied_part.."@w"
            end
            copied_text = copied_text..(((copied_part ~= nil) and copied_part) or "")
         end -- if valid line
      end -- for

      if ypos < TITLE_HEIGHT then
         keepscrolling = "up"
         scrollbar()
      elseif ypos > height then
         keepscrolling = "down"
         scrollbar()
      else
         keepscrolling = ""
         writeLines()
      end
   end -- if left mouse button
end -- function TextareaMoveCallback

function TextareaReleaseCallback(flags, hotspot_id)
   copy_start_line = math.min(#lines, copy_start_line or 0)
   copy_end_line = math.min(#lines, copy_end_line or 0)
end

function LeftClickOnly(flags, hotspot_id, win)
   if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
      return true
   end
   return false
end

--=================================================================================
-- Called when plugin receives telnet data - main entry point for actually running
-- the plugin.
--=================================================================================
function OnPluginBroadcast (msg, id, name, text)
  if (id == "462b665ecb569efbf261422f" and msg==996 and text == "re-register z") then
      CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", win)
   end
end


function chat_echo (name, line, wildcards)
   if wildcards [1] == false then
      echo = not echo
   elseif wildcards [1]:lower () == " on" then
      echo = 1
   elseif wildcards [1]:lower () == " off" then
      echo = 0
   end -- if

   if echo == 1 then
      ColourNote ("yellow", "", "主屏信息 关闭显示.")
   else
      ColourNote ("yellow", "", "主屏信息 打开显示.")
   end -- if
end -- chat_echo

function chat_show (name, line, wildcards)
   WindowShow( win, true )
   ColourNote ("yellow", "", "聊天窗口显示. 输入 'chats hide' 隐藏聊天窗口.")
end -- function chat_show

function chat_hide (name, line, wildcards)
   WindowShow( win, false )
   ColourNote ("yellow", "", "聊天窗口隐藏. 输入 'chats show' 重新显示聊天窗口.")
end -- function chat_hide

-- right click menu
function right_click_menu (hotspot_id)
   hotspots = {scroller=true, resize=true, down=true, up=true, textarea=true}
   menustring ="!"
   local hyperlink_skip = 0
   if (WindowInfo(win, 15) > TITLE_HEIGHT) and not hotspots[hotspot_id] then
      hyperlink_skip = 2
      menustring = menustring.."Go to URL: "..hyperlinks[hotspot_id].."|Copy URL to Clipboard|-|"
   end
   menustring = menustring.."无格式复制选择|复制选择|全部复制|-|更改字体"
   if echo == 1 then
      menustring = (menustring.."|主屏信息 关闭显示")
   else
      menustring = (menustring.."|主屏信息 打开显示")
   end --if

   menustring = menustring.."|>时间戳格式|"..((date_format=="" and "+") or "").."无时间戳|"..((date_format=="[%d %b %H:%M:%S] " and "+") or "").."30 Aug 13:29:49|"..((date_format=="[%d %b %I:%M:%S%p] " and "+") or "").."30 Aug 01:20:12PM|"..((date_format=="[%H:%M:%S] " and "+") or "").."13:29:08|"..((date_format=="[%I:%M:%S%p] " and "+") or "").."1:22:06 PM|<|>频道状态|"..((rumor_on==1 and "+") or "").."谣言频道|"..((quest_on==1 and "+") or "").."解密记录|"..((quyu_on==1 and "+") or "").."门派频道|"..((siliao_on==1 and "+") or "").."私聊频道|"..((duiwu_on==1 and "+") or "").."队伍频道|"..((baowu_on==1 and "+") or "").."宝物频道|"..((renwu_on==1 and "+") or "").."任务频道|".."<|-|>记录到文件|"..((log_to_file==1 and "停止记录|") or "开始记录|")..((log_colour_codes==0 and "+") or "").."去除颜色代码|"..((log_timestamps==0 and "+") or "").."去除时间戳|<|-|上移一层|下移一层"
   result = WindowMenu (win,
      WindowInfo (win, 14),  -- x position
      WindowInfo (win, 15),   -- y position
      menustring) -- content
   if result ~= "" then
      numResult = tonumber(result)
      if numResult == hyperlink_skip-1 then
         local res = OpenBrowser(hyperlinks[hotspot_id])
         if res ~= 0 then
            SetClipboard(hyperlinks[hotspot_id])
            ColourNote("yellow", "red", "MUSHclient may have encountered an error trying to open the selected URL. It has been copied to the clipboard.")
            ColourNote("cyan","","v-------------------Copied to clipboard-------------------v")
            ColourNote("yellow","",hyperlinks[hotspot_id])
            ColourNote("cyan","","^---------------------------------------------------------^")
         end
      elseif numResult == hyperlink_skip then
         SetClipboard(hyperlinks[hotspot_id])
         ColourNote("cyan","","v-------------------Copied to clipboard-------------------v")
         ColourNote("yellow","",hyperlinks[hotspot_id])
         ColourNote("cyan","","^---------------------------------------------------------^")
      elseif numResult == 1+hyperlink_skip then
         if #copied_text > 0 then
            local declored_text = strip_colours(copied_text)
            SetClipboard(declored_text)
            ColourNote("cyan","","v-------------------Copied to clipboard-------------------v")
            ColourNote("yellow","",declored_text)
            ColourNote("cyan","","^---------------------------------------------------------^")
         end
      elseif numResult == 2+hyperlink_skip then
         if #copied_text > 0 then
            SetClipboard(copied_text)
            ColourNote("cyan","","v-------------------Copied to clipboard-------------------v")
            ColourNote("yellow","",copied_text)
            ColourNote("cyan","","^---------------------------------------------------------^")
         end
      elseif numResult == 3+hyperlink_skip then
         GetAllBufferedMessages()
         ColourNote ("yellow", "", "所有聊天信息复制到剪贴板")
      elseif numResult == 4+hyperlink_skip then
         wanted_font = utils.fontpicker (font_name, font_size) --font dialog
         if wanted_font then
            font_name = wanted_font.name
            font_size = wanted_font.size
            SetVariable ("font_name", font_name)
            SetVariable ("font_size", font_size)
            OnPluginInstall()
         end
      elseif numResult == 5+hyperlink_skip then
         if echo == 1 then
            echo = 0
            ColourNote ("yellow", "", "主屏信息显示关闭.")
         else
            echo = 1
            ColourNote ("yellow", "", "主屏信息显示打开.")
         end
      elseif numResult == 6+hyperlink_skip then
         date_format = ""
         ColourNote ("yellow", "", "聊天窗口不显示时间戳.")
      elseif numResult == 7+hyperlink_skip then
         date_format = "[%d %b %H:%M:%S] "
         ColourNote ("yellow", "", "聊天窗口显示时间戳格式>> 30 Aug 13:29:49 <<。")
      elseif numResult == 8+hyperlink_skip then
         date_format = "[%d %b %I:%M:%S%p] "
         ColourNote ("yellow", "", "聊天窗口显示时间戳格式>> 30 Aug 01:20:12PM <<。")
      elseif numResult == 9+hyperlink_skip then
         date_format = "[%H:%M:%S] "
         ColourNote ("yellow", "", "聊天窗口显示时间戳格式>> 13:29:08 <<。")
      elseif numResult == 10+hyperlink_skip then
         date_format = "[%I:%M:%S%p] "
         ColourNote ("yellow", "", "聊天窗口显示时间戳格式>> 1:22:06 PM <<。")

      elseif numResult == 11+hyperlink_skip then
         EnableTrigger("rumor", 0 == rumor_on)
         rumor_on = GetTriggerOption("rumor","enabled")

      elseif numResult == 12+hyperlink_skip then
         EnableTrigger("quest", 0 == quest_on)
         quest_on = GetTriggerOption("quest","enabled")

      elseif numResult == 13+hyperlink_skip then
         EnableTrigger("quyu", 0 == quyu_on)
         quyu_on = GetTriggerOption("quyu","enabled")

      elseif numResult == 14+hyperlink_skip then
         EnableTrigger("siliao", 0 == siliao_on)
         siliao_on = GetTriggerOption("siliao","enabled")

      elseif numResult == 15+hyperlink_skip then
         EnableTrigger("duiwu", 0 == duiwu_on)
         duiwu_on = GetTriggerOption("duiwu","enabled")

      elseif numResult == 16+hyperlink_skip then
         EnableTrigger("baowu", 0 == baowu_on)
         baowu_on = GetTriggerOption("baowu","enabled")

      elseif numResult == 17+hyperlink_skip then
         EnableTrigger("reward", 0 == renwu_on)
		  EnableTrigger("exp", 0 == renwu_on)
		   EnableTrigger("pots", 0 == renwu_on)
		    EnableTrigger("shen", 0 == renwu_on)
			EnableTrigger("ss", 0 == renwu_on)
         renwu_on = GetTriggerOption("reward","enabled")

      elseif numResult == 18+hyperlink_skip then
         log_to_file = (((0 == log_to_file) and 1) or 0)
         SetVariable("log_to_file", log_to_file)

      elseif numResult == 19+hyperlink_skip then
         log_colour_codes = (((0 == log_colour_codes) and 1) or 0)
         SetVariable("log_colour_codes", log_colour_codes)

      elseif numResult == 20+hyperlink_skip then
         log_timestamps = (((0 == log_timestamps) and 1) or 0)
         SetVariable("log_timestamps", log_timestamps)

      elseif numResult == 21+hyperlink_skip then
         CallPlugin("462b665ecb569efbf261422f","boostMe", win)

      elseif numResult == 22+hyperlink_skip then
         CallPlugin("462b665ecb569efbf261422f","dropMe", win)
      end
   end
end -- right_click_menu

]]>
</script>
</muclient>
